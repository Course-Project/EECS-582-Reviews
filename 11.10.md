KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs
===

###### Cristian Cadar, Daniel Dunbar, and Dawson Engler

###### Reviewer: Shengtuo Hu (shengtuo@umich.edu)

---

### What is the Problem?

Many classes of errors, such as functional correctness bugs, are difficult to find without executing a piece of code. However, the handful writing test cases are time-consuming and affected by programmers' preconceptions. Therefore, many research works started using symbolic execution to automatically generate test inputs. Nonetheless, there exist two common concerns: (1) the path explosion problem; (2) the environment problem. Most past works cannot solve these two problems fundamentally.

### Summary

The authors present a new symbolic execution tool, KLEE, which employs a variety of constraint solving optimizations, represents program states compactly, and uses search heuristics to get high code coverage. On the other hand, KLEE handles the environment by redirecting calls that access it to models that understand the semantics of the desired action well enough to generate the required constraints. With these improvements, KLEE can automatically generate tests on a diverse set of real, complicated, and environmentally-intensive programs.

### Key Insights

- Constraints on same variables tend to become more specific. Based on this insight, KLEE optimizes its query process and designs several optimization strategies.
- It is important to ensure the software's quality, but the handful writing test cases are time-consuming, costly, and affected by programmers' preconceptions. Those heavily-tested codes can also have long-standing and serious bugs.

### Notable Design Details/Strengths

- KLEE utilizes several strategies for query optimizations: (1) expression rewriting (e.g., simple arithmetic simplifications, strength reduction, linear simplification); (2) constraint set simplification; (3) implied value concretization; (4) constraint independence; (5) counter-example cache. The first one mirrors the similar strategy in a compiler. The second one is based on a finding that constraints on same variables tend to become more specific. KLEE will rewrite previous constraints while new equality constraints are added to the constraint set. The third one is similar to solving equations such that subsequent accesses of that memory location can return a cheap constant expression. The fourth one simplifies queries by eliminating irrelevant constraints before sending a query to the constraint solver. The last one further speed up the query by caching set of constraints to counter-examples, along with a special sentinel used when a set of constraints has no solution.
- KLEE handles environment problem by redirecting calls that access it to models, which simulate their effects and keep all the side effects in per-state storage. Since these models understand the semantics of the desired action well enough, they can generate the promising constraints.

### Limitations/Weaknesses

- For `sort` in COREUTILS, KLEE cannot achieve high-coverage results, because `sort` requires a single edit to shink a large buffer that caused problems for the constraint solver.
- KLEE does not fundamentally solve the problem that a pointer can refer to many objects. Instead, it sidesteps this problem by cloning the current state for each possible object to which the pointer refers. In this paper, most programs the authors tested only use symbolic pointers that refer to a single object, and KLEE, therefore, gets promising results. However, this method can still be expensive for pointers with large points-to sets.
- Although modeling the environment can generate correct results, it still leads to the disadvantage that the developer needs to implement and maintain many potentially complex models of system calls.

### Summary of Key Results

- KLEE can get much more code coverage than a concentrated, sustained manual effort. The test cases automatically generated by KLEE for COREUTILS beat those test suite manually written by the developers and hold 16.8% higher coverage.
- KLEE can also be used in testing non-application codes (e.g., kernel). The authors applied KLEE to the core of the HISTAR kernel and got an average line coverage of 76.4% (with disk) and 67.1% (without disk).
- For those heavily-tested codes, KLEE can still found important errors. In this paper, the authors reported that they found a total of 56 serious bugs in BUSYBOX, MINIX, AND HISTAR. As well, among ten fatal errors in COREUTILS, there exist three bugs that had escaped detection for 15 years.

### Open Questions

For symbolic execution, there always exist two open questions: (1) the path explosion problem; (2) the environment problem. KLEE only utilizes some insights and tricks to optimize its performance, but it does not fundamentally address these two problems. For the first problem, using heuristics for path-finding, parallelizing independent paths for time-saving, and merging similar paths may be helpful. For the second one, KLEE decides to use environment model, while there also exist other solutions, such as executing calls to the environment directly and forking the entire system state. Each solution has its own advantages and disadvantages. One should make the design decision based on requirements and scenarios of the program.
